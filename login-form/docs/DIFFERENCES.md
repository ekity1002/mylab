# セッションベース認証 vs JWT認証

このドキュメントでは、セッションベース認証とJWT（JSON Web Token）認証の違いについて詳しく解説します。

## 目次

1. [概要](#概要)
2. [セッションベース認証](#セッションベース認証)
3. [JWT認証](#jwt認証)
4. [主な違い](#主な違い)
5. [使い分けのガイドライン](#使い分けのガイドライン)
6. [セキュリティ考慮事項](#セキュリティ考慮事項)

---

## 概要

認証（Authentication）は、ユーザーが本人であることを確認するプロセスです。Web アプリケーションでは、主に以下の2つの認証方式が使われています：

- **セッションベース認証**: サーバー側でセッション情報を管理
- **JWT認証**: トークンベースでステートレスな認証

---

## セッションベース認証

### 仕組み

1. ユーザーがログイン情報（ユーザー名、パスワード）を送信
2. サーバーが認証情報を検証
3. 認証成功時、サーバーは**セッションID**を生成し、セッションストアに保存
4. セッションIDをクライアントに**Cookie**として送信
5. 以降のリクエストで、ブラウザは自動的にCookieを送信
6. サーバーはセッションIDを使って、セッションストアからユーザー情報を取得

### 特徴

#### メリット

- **サーバー側で完全に制御可能**
  - セッションの無効化が即座に可能
  - ユーザーのログアウトを強制できる

- **シンプルな実装**
  - ブラウザがCookieを自動管理
  - 追加のヘッダー設定が不要

- **セッション情報の柔軟性**
  - セッションストアに任意のデータを保存可能
  - 権限の変更がリアルタイムで反映

#### デメリット

- **スケーラビリティの課題**
  - セッションストアが必要（Redis、Memcachedなど）
  - 複数サーバーでセッション共有が必要

- **CSRF攻撃のリスク**
  - Cookieベースのため、CSRF対策が必須
  - CSRFトークンの実装が必要

- **モバイルアプリとの相性が悪い**
  - Cookie管理が複雑
  - ネイティブアプリでの実装が困難

### データフロー

```
[クライアント] ─── ログイン ───→ [サーバー]
                                    ↓
                               認証情報検証
                                    ↓
                           セッションID生成
                                    ↓
                      [セッションストア]に保存
                                    ↓
[クライアント] ←── Cookie送信 ──── [サーバー]
     ↓
 Cookieに保存
     ↓
[クライアント] ─── リクエスト ───→ [サーバー]
  (Cookie自動送信)                  ↓
                          セッションID検証
                                    ↓
                         [セッションストア]
                           からユーザー情報取得
```

### 実装例（このプロジェクト）

```typescript
// sessionStorageを使用（本番環境ではサーバー側Cookie）
sessionStorage.setItem(SESSION_KEY, JSON.stringify(user));

// セッション取得
const sessionData = sessionStorage.getItem(SESSION_KEY);
```

**注意**: このプロジェクトでは学習目的で`sessionStorage`を使用していますが、本番環境では：
- サーバー側でセッション管理
- HttpOnlyフラグ付きCookieを使用
- Secure属性でHTTPS通信のみに限定

---

## JWT認証

### 仕組み

1. ユーザーがログイン情報を送信
2. サーバーが認証情報を検証
3. 認証成功時、サーバーは**JWTトークン**を生成
4. トークンをクライアントに送信
5. クライアントはトークンを**localStorage**または**sessionStorage**に保存
6. 以降のリクエストで、`Authorization`ヘッダーにトークンを含めて送信
7. サーバーはトークンを検証し、ユーザー情報を取得

### JWTの構造

JWTは3つの部分で構成されています：

```
header.payload.signature
```

#### Header（ヘッダー）

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- `alg`: 署名アルゴリズム（HS256、RS256など）
- `typ`: トークンタイプ

#### Payload（ペイロード）

```json
{
  "user": {
    "id": "1",
    "username": "testuser",
    "email": "test@example.com"
  },
  "exp": 1640000000000,
  "iat": 1639996400000
}
```

- `user`: ユーザー情報
- `exp`: 有効期限（タイムスタンプ）
- `iat`: 発行日時（タイムスタンプ）

#### Signature（署名）

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

- ヘッダーとペイロードを秘密鍵で署名
- 改ざん検知に使用

### 特徴

#### メリット

- **ステートレス**
  - サーバー側でセッション管理が不要
  - スケーラビリティが高い

- **マイクロサービスに適している**
  - トークン自体に情報が含まれる
  - 異なるサービス間で認証情報を共有可能

- **モバイルアプリに適している**
  - Cookieに依存しない
  - APIベースの認証に最適

- **CORS対応が容易**
  - 異なるドメイン間での認証が簡単

#### デメリット

- **トークンの無効化が困難**
  - トークンが有効期限内は無効化できない
  - ブラックリスト管理が必要（ステートレスの利点を失う）

- **トークンサイズが大きい**
  - 各リクエストでトークンを送信するため、帯域幅を消費

- **XSS攻撃のリスク**
  - localStorageに保存した場合、XSS攻撃に脆弱
  - 適切なサニタイゼーションが必須

- **リフレッシュトークンの管理**
  - アクセストークンとリフレッシュトークンの2つが必要
  - 実装が複雑になる

### データフロー

```
[クライアント] ─── ログイン ───→ [サーバー]
                                    ↓
                               認証情報検証
                                    ↓
                              JWTトークン生成
                                    ↓
[クライアント] ←── トークン ───── [サーバー]
     ↓
localStorageに保存
     ↓
[クライアント] ─── リクエスト ───→ [サーバー]
  (Authorizationヘッダー)           ↓
                              トークン検証
                                    ↓
                         ペイロードから
                        ユーザー情報取得
```

### 実装例（このプロジェクト）

```typescript
// トークン保存
localStorage.setItem(TOKEN_KEY, token);

// APIリクエスト時
headers: {
  'Authorization': `Bearer ${token}`
}

// トークンデコード（簡易版）
const payload = JSON.parse(atob(token.split('.')[1]));
```

**注意**: このプロジェクトでは学習目的で簡易的なトークン生成を使用していますが、本番環境では：
- サーバー側で適切なライブラリを使用（jsonwebtoken など）
- 強力な秘密鍵を使用
- 適切な有効期限を設定
- リフレッシュトークンを実装

---

## 主な違い

| 項目 | セッションベース認証 | JWT認証 |
|------|---------------------|---------|
| **状態管理** | ステートフル（サーバー側） | ステートレス（クライアント側） |
| **保存場所** | サーバー側セッションストア + Cookie | クライアント側（localStorage/sessionStorage） |
| **スケーラビリティ** | セッション共有が必要 | 容易にスケール可能 |
| **無効化** | 即座に可能 | 困難（有効期限まで待つ） |
| **データサイズ** | 小さい（SessionIDのみ） | 大きい（ユーザー情報含む） |
| **実装の複雑さ** | シンプル | やや複雑 |
| **モバイル対応** | 困難 | 容易 |
| **CSRF対策** | 必要 | 不要（Cookieを使わない場合） |
| **XSS対策** | HttpOnly Cookieで緩和 | より注意が必要 |
| **マイクロサービス** | 共有が困難 | 適している |

---

## 使い分けのガイドライン

### セッションベース認証が適している場合

1. **モノリシックアプリケーション**
   - 単一のサーバーで完結
   - セッション管理が容易

2. **強力なセキュリティが必要**
   - セッションの即座の無効化が必要
   - ユーザーのログアウト強制が必要

3. **従来型のWebアプリケーション**
   - サーバーサイドレンダリング
   - フォームベースの認証

4. **小〜中規模のアプリケーション**
   - スケーリングの必要性が低い

### JWT認証が適している場合

1. **マイクロサービスアーキテクチャ**
   - 複数のサービス間で認証情報を共有
   - ステートレスな設計

2. **SPA（Single Page Application）**
   - React、Vue、Angularなど
   - APIベースの通信

3. **モバイルアプリケーション**
   - iOS、Android
   - Cookie管理が困難

4. **大規模アプリケーション**
   - 水平スケーリングが必要
   - 高トラフィック

5. **異なるドメイン間の認証**
   - CORS対応が必要
   - 複数のサブドメイン

---

## セキュリティ考慮事項

### セッションベース認証

#### 必須の対策

1. **HttpOnly Cookie**
   ```javascript
   Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict
   ```
   - JavaScriptからアクセス不可
   - XSS攻撃を緩和

2. **Secure属性**
   - HTTPS通信のみで送信
   - 中間者攻撃を防止

3. **SameSite属性**
   - CSRF攻撃を防止
   - `Strict`または`Lax`を設定

4. **CSRFトークン**
   - フォームに一意のトークンを含める
   - サーバー側で検証

5. **セッションの有効期限**
   - アイドルタイムアウトを設定
   - 絶対タイムアウトを設定

### JWT認証

#### 必須の対策

1. **適切な保存場所**
   - `localStorage`: XSS攻撃に脆弱
   - HttpOnly Cookie: CSRF対策が必要だが、XSS対策には有効
   - 推奨: HttpOnly Cookie + CSRF対策

2. **短い有効期限**
   - アクセストークン: 15分〜1時間
   - リフレッシュトークン: 1日〜1週間

3. **リフレッシュトークンの実装**
   ```
   アクセストークン（短期）+ リフレッシュトークン（長期）
   ```

4. **署名の検証**
   - 改ざん検知
   - 強力なアルゴリズム（RS256推奨）

5. **XSS対策**
   - Content Security Policy (CSP)
   - 入力のサニタイゼーション
   - 出力のエスケープ

6. **トークンのブラックリスト**
   - ログアウト時にトークンを無効化
   - Redis等で管理（ステートレスの利点を一部失う）

### 共通の対策

1. **HTTPS通信**
   - すべての通信を暗号化

2. **パスワードのハッシュ化**
   - bcrypt、argon2など
   - ソルトの使用

3. **レート制限**
   - ブルートフォース攻撃を防止

4. **多要素認証（MFA）**
   - より強力なセキュリティ

---

## ハンズオン学習の進め方

### 1. お手本の確認

まず、`src/example/`フォルダ内の完成版コードを確認してください：

- `src/example/session/`: セッションベース認証の完成版
- `src/example/jwt/`: JWT認証の完成版

### 2. 実装にチャレンジ

`src/practice/`フォルダ内のテンプレートを使って、自分で実装してみましょう：

- `src/practice/session/`: セッションベース認証の実装用
- `src/practice/jwt/`: JWT認証の実装用

各ファイルには`TODO`コメントがあり、実装のヒントが記載されています。

### 3. テストの実装

`tests/`フォルダ内でユニットテストを実装してください：

- `tests/example/`: お手本のテスト
- `tests/practice/`: 自分の実装のテスト

### 4. 動作確認

```bash
# 開発サーバーの起動
npm run dev

# テストの実行
npm test

# テストカバレッジの確認
npm run test:coverage
```

---

## 参考資料

- [JWT.io](https://jwt.io/) - JWTの詳細情報
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
- [MDN Web Docs - HTTP Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
- [RFC 7519 - JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519)

---

## まとめ

セッションベース認証とJWT認証には、それぞれメリットとデメリットがあります。プロジェクトの要件、アーキテクチャ、セキュリティ要件に応じて、適切な認証方式を選択することが重要です。

多くの場合、ハイブリッドアプローチ（セッションとJWTの組み合わせ）も有効な選択肢となります。

このハンズオン環境を通じて、両方の認証方式を実装し、その違いを体感してください。
